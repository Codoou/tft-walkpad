import asyncio
import time
from dataclasses import dataclass
from typing import Optional, Dict, Any

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from bleak import BleakScanner, BleakClient

# ---- FTMS UUIDs ----
TREADMILL_DATA = "00002acd-0000-1000-8000-00805f9b34fb"   # Notify
CONTROL_POINT  = "00002ad9-0000-1000-8000-00805f9b34fb"   # Write + Indicate

# ---- FTMS Control Point opcodes ----
OP_REQUEST_CONTROL   = 0x00
OP_SET_TARGET_SPEED  = 0x02
OP_START_OR_RESUME   = 0x07
OP_STOP_OR_PAUSE     = 0x08

# ---- Configure this ----
TREADMILL_NAME = "TM06BK"  # from your output

def u16_le(n: int) -> bytes:
    return bytes([n & 0xFF, (n >> 8) & 0xFF])

def u16_from(payload: bytes, i: int) -> int:
    return payload[i] | (payload[i + 1] << 8)

@dataclass
class Telemetry:
    flags: int
    speed_kmh: Optional[float] = None
    raw_hex: str = ""

def parse_treadmill_data(payload: bytes) -> Telemetry:
    # Minimal + safe: flags + instantaneous speed (common FTMS layout)
    if len(payload) < 4:
        return Telemetry(flags=0, speed_kmh=None, raw_hex=payload.hex())

    flags = u16_from(payload, 0)
    speed_raw = u16_from(payload, 2)  # often 0.01 km/h units
    speed_kmh = speed_raw / 100.0

    return Telemetry(flags=flags, speed_kmh=speed_kmh, raw_hex=payload.hex())

class FTMSController:
    def __init__(self, name: str):
        self.name = name
        self.client: Optional[BleakClient] = None
        self.device_address: Optional[str] = None

        self.last_cp: Optional[bytes] = None
        self.last_tm: Optional[Telemetry] = None
        self.last_tm_ts: Optional[float] = None

        self._lock = asyncio.Lock()
        self._stop_event = asyncio.Event()
        self._runner_task: Optional[asyncio.Task] = None

    # ---- BLE callbacks ----
    def _on_cp(self, _: int, data: bytearray):
        self.last_cp = bytes(data)

    def _on_tm(self, _: int, data: bytearray):
        self.last_tm = parse_treadmill_data(bytes(data))
        self.last_tm_ts = time.time()

    async def _write_cp(self, payload: bytes):
        if not self.client or not self.client.is_connected:
            raise RuntimeError("Not connected")
        await self.client.write_gatt_char(CONTROL_POINT, payload, response=True)

    async def _connect_once(self) -> bool:
        # Find treadmill (cache address once found)
        if not self.device_address:
            devices = await BleakScanner.discover(timeout=5.0)
            for d in devices:
                if d.name and self.name.lower() == d.name.lower():
                    self.device_address = d.address
                    break

        if not self.device_address:
            return False

        self.client = BleakClient(self.device_address)
        await self.client.connect(timeout=10.0)

        # Subscribe
        await self.client.start_notify(CONTROL_POINT, self._on_cp)
        await self.client.start_notify(TREADMILL_DATA, self._on_tm)

        # Request control
        await self._write_cp(bytes([OP_REQUEST_CONTROL]))
        return True

    async def _disconnect(self):
        if self.client:
            try:
                if self.client.is_connected:
                    try:
                        await self.client.stop_notify(TREADMILL_DATA)
                    except Exception:
                        pass
                    try:
                        await self.client.stop_notify(CONTROL_POINT)
                    except Exception:
                        pass
                    await self.client.disconnect()
            finally:
                self.client = None

    async def runner(self):
        # Keep connection alive + reconnect loop
        backoff = 1.0
        while not self._stop_event.is_set():
            try:
                ok = await self._connect_once()
                if not ok:
                    await asyncio.sleep(backoff)
                    backoff = min(backoff * 1.5, 10.0)
                    continue

                backoff = 1.0  # reset after success

                # Stay connected until it drops or server stops
                while not self._stop_event.is_set():
                    if not self.client or not self.client.is_connected:
                        break
                    await asyncio.sleep(1.0)

            except Exception:
                # swallow and retry
                await asyncio.sleep(backoff)
                backoff = min(backoff * 1.5, 10.0)
            finally:
                await self._disconnect()

    async def start_background(self):
        if self._runner_task and not self._runner_task.done():
            return
        self._stop_event.clear()
        self._runner_task = asyncio.create_task(self.runner())

    async def stop_background(self):
        self._stop_event.set()
        if self._runner_task:
            await asyncio.sleep(0)  # let task notice stop_event
        await self._disconnect()

    # ---- Public commands (locked so you don't interleave writes) ----
    async def start(self):
        async with self._lock:
            await self._write_cp(bytes([OP_START_OR_RESUME]))

    async def stop(self, mode: str = "stop"):
        # mode: "stop" or "pause"
        param = 0x01 if mode == "stop" else 0x02
        async with self._lock:
            await self._write_cp(bytes([OP_STOP_OR_PAUSE, param]))

    async def set_speed_kmh(self, kmh: float):
        # Most FTMS treadmills: 0.01 km/h uint16
        raw = int(round(max(0.0, kmh) * 100))
        async with self._lock:
            await self._write_cp(bytes([OP_SET_TARGET_SPEED]) + u16_le(raw))

    def status(self) -> Dict[str, Any]:
        connected = bool(self.client and self.client.is_connected)
        return {
            "name": self.name,
            "address": self.device_address,
            "connected": connected,
            "last_control_point_hex": self.last_cp.hex() if self.last_cp else None,
            "telemetry": {
                "flags": f"0x{self.last_tm.flags:04x}" if self.last_tm else None,
                "speed_kmh": self.last_tm.speed_kmh if self.last_tm else None,
                "raw_hex": self.last_tm.raw_hex if self.last_tm else None,
                "ts": self.last_tm_ts,
            },
        }

# ---- FastAPI ----
app = FastAPI(title="Walkpad FTMS API")
ctl = FTMSController(TREADMILL_NAME)

class SpeedIn(BaseModel):
    kmh: float

class StopIn(BaseModel):
    mode: str = "stop"  # "stop" or "pause"

@app.on_event("startup")
async def on_startup():
    await ctl.start_background()

@app.on_event("shutdown")
async def on_shutdown():
    await ctl.stop_background()

@app.get("/status")
async def get_status():
    return ctl.status()

@app.post("/start")
async def post_start():
    try:
        await ctl.start()
        return {"ok": True}
    except Exception as e:
        raise HTTPException(status_code=409, detail=str(e))

@app.post("/stop")
async def post_stop(body: StopIn):
    if body.mode not in ("stop", "pause"):
        raise HTTPException(status_code=400, detail="mode must be 'stop' or 'pause'")
    try:
        await ctl.stop(mode=body.mode)
        return {"ok": True}
    except Exception as e:
        raise HTTPException(status_code=409, detail=str(e))

@app.post("/speed")
async def post_speed(body: SpeedIn):
    # be conservative; tweak if your treadmill allows more
    if body.kmh < 0 or body.kmh > 20:
        raise HTTPException(status_code=400, detail="kmh out of reasonable range")
    try:
        await ctl.set_speed_kmh(body.kmh)
        return {"ok": True, "kmh": body.kmh}
    except Exception as e:
        raise HTTPException(status_code=409, detail=str(e))